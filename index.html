<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="Hexo" rel="home">Hexo</a>
      </h1>
      
        <script type="text/javascript" src="http://api.hitokoto.us/rand?encode=js&charset=utf-8"></script>
        <h2 class="site-description"><script>hitokoto();</script></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-Journals-and-Conference" class="post-Journals-and-Conference post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/11/01/Journals-and-Conference/">Journals and Conference</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/11/01/Journals-and-Conference/" data-id="cj9h1sgjx00026azr8jaamkhq" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>#研究生期间需要的会议以及期刊<br><a href="http://xutong.info/2014/08/summary_of_optical_conferences_and_jounals/#respond" target="_blank" rel="external">原地址：</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我在一所211大学，研究量子光网络方向，收集了一些在研究生期间可能会投的或者比较重要的会议以及期刊。总的来说，可以投稿的会议主要有OFC、ECOC、CLEO、OECC、ACP等，期刊则有OE、OL、PTL、JLT、PJ、AO、JOSA、小OE、EL、OC和COL，下面进行一个简单的介绍。</p>
<p>先说会议，OFC、ECOC和CLEO是光通信领域三大顶级会议，其中OFC和ECOC分别在美国和欧洲开，这两个是光通信领域最牛的会议了，CLEO稍微次一点，但也挺不错的。OECC则更次一些。ACP则比OECC还要次一些，而且我们组一般不愿意你投ACP，除非是涉及到毕业的问题。</p>
<h2 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h2><h3 id="OFC"><a href="#OFC" class="headerlink" title="OFC"></a>OFC</h3><p>OFC的全称是Optical Fiber Communication Conference，中文名是光纤通信会议。OFC算是级别非常高的会议了，论文也很难中。<a href="http://www.ofcconference.org/home/" target="_blank" rel="external">OFC</a></p>
<h3 id="ECOC"><a href="#ECOC" class="headerlink" title="ECOC"></a>ECOC</h3><p>ECOC的全称是European Conference on Optical Communications，中文名是欧洲光通信会议。ECOC也是光通信领域的顶级会议，和OFC一个级别的。不过感觉ECOC比OFC难中。ECOC可能更偏向于收录欧洲那边的文章，这也许也是难中的一个原因吧。<a href="http://www.ecoc2014.org/" target="_blank" rel="external">ECOC</a></p>
<h3 id="CLEO"><a href="#CLEO" class="headerlink" title="CLEO"></a>CLEO</h3><p>CLEO的全称是Conference on Lasers and Electro-Optics，中文名是激光及光电会议。CLEO虽然与OFC、ECOC并称光通信三大顶级会议，但实际上它比后两者级别低一些。CLEO的文章还算是比较好中的，但一般需要有实验才行。CLEO比较悲催的是它是在OFC之后开，于是很多研究者就把被OFC拒稿的文章投到CLEO上，其论文质量当然比OFC低了一个档次。据说，为了防止大家把OFC拒稿的文章转投CLEO，CLEO方曾经试着把论文截稿日期放在OFC论文录用通知之前。结果导致某一年CLEO收录的文章数居然不够，于是他们只好放弃了这个做法。总之CLEO在OFC之后，略有点悲催咯。<a href="http://www.cleoconference.org/" target="_blank" rel="external">CLEO</a></p>
<h3 id="ACP"><a href="#ACP" class="headerlink" title="ACP"></a>ACP</h3><p>ACP的全称是Asia Communications and Photonics Conference and Exhibition，中文名是亚洲光纤通信与光电国际会议。ACP比OECC还要水一些，上面的水文就特别多了，去年我们实验室投这个会议的几乎全部中了。我们传输组现在已经不让投ACP了。不过虽然ACP挺水，但上面还是有不少好的文章，而且国外很多大牛也会来参会。所以参加ACP可以作为一个和国内外学术大牛交流的好机会<a href="http://www.acp-conf.org/" target="_blank" rel="external">ACP</a></p>
<h2 id="期刊"><a href="#期刊" class="headerlink" title="期刊"></a>期刊</h2><p>再来说一下期刊，一般主要投的就是OE、OL、PTL、JLT，这四个期刊都很好。似乎PJ也很好，不过不太了解。接下来就是AO、JOSA、小OE、EL、OC和COL了。其中，OE、OL、AO、JOSA、COL都是OSA下面的期刊，而PTL、JLT、PJ、EL则是IEEE下面的期刊，小OE是SPIE下面的期刊，我将分别论述一下。</p>
<h3 id="OE"><a href="#OE" class="headerlink" title="OE"></a>OE</h3><p>OE的全称是Optics Express，最新影响因子为3.525（2013年）。OE是OSA（美国光学协会）下的期刊，我们一般称之为大OE，里面很多论文质量都很高。但近年来随着投稿量的增多，OE也成为灌水的地方。一位师兄说现在OE上的水文多了去了。OE的排版是单栏，而且篇幅没有限制，我见到的OE文章大都在十页左右，很少有低于6页的。OE的审稿大约俩个月，不算非常难中。<a href="http://www.opticsinfobase.org/oe/home.cfm" target="_blank" rel="external">OE</a></p>
<h3 id="OL"><a href="#OL" class="headerlink" title="OL"></a>OL</h3><p>OL的全称是Optics Letters，最新影响因子为3.179（2013年）。OL的排版是双栏，而且篇幅限制为4页。我们通常把OL和OE并称，虽然OL的影响因子比OE还低一点，但实际上OL更难投中，个人感觉整体上OL上的论文质量比OE高，水文出现概率小。<a href="http://www.opticsinfobase.org/ol/home.cfm" target="_blank" rel="external">OL</a></p>
<h3 id="PTL"><a href="#PTL" class="headerlink" title="PTL"></a>PTL</h3><p>PTL的全称是Photonics Technology Letters，最新影响因子为2.176（2013年）。PTL的排版也是双栏，而且篇幅限制为4页，我们组一位师姐去年就在上面发过文章，感觉比OL好中一些。具体情况我不太清楚了，<a href="http://photonicssociety.org/content/photonics-technology-letters" target="_blank" rel="external">PTL</a></p>
<h3 id="JTL"><a href="#JTL" class="headerlink" title="JTL"></a>JTL</h3><p>JLT的全称是Journal of lightwave technology，最新影响因子为2.862（2013年）。JLT的论文篇幅通常比较长，而且论述很详尽。感觉JLT整体上比较学术，很适合系统地学习某一方向的知识，可以说是期刊里面的业界良心。<a href="http://photonicssociety.org/content/ieeeosa-journal-lightwave-technology" target="_blank" rel="external">JTL</a></p>
<h3 id="PL"><a href="#PL" class="headerlink" title="PL"></a>PL</h3><p>PJ的全称是Photonics Journal，最新影响因子为2.33（2013年）。PJ是IEEE下面的期刊，对它不太了解。看过上面几篇有关空间光通信信道仿真的论文，感觉里面的理论推导特别详细，尤其是数学公式很多。<a href="http://www.photonicsjournal.org/" target="_blank" rel="external">PL</a></p>
<h3 id="AO"><a href="#AO" class="headerlink" title="AO"></a>AO</h3><p>AO的全称是Applied Optics，最新影响因子为1.649（2013年）。AO是单栏，我见到的篇幅都比较长，在8页以上，几乎没有低于6页的。AO上很多文章都是纯光学的，和光通信的关系并不是很大了，感觉上面的文章理论也非常详细。<a href="http://www.opticsinfobase.org/ao/home.cfm" target="_blank" rel="external">AO</a></p>
<h3 id="JOSA"><a href="#JOSA" class="headerlink" title="JOSA"></a>JOSA</h3><p>JOSA的全称是Journal of the Optical Society of America，据查还有JOSA A和JOSA B之分，两个的最新影响因子分别为1.448和1.806（2013年）。对它了解也不多，感觉风格跟AO类似，也是属于OSA里面的期刊。似乎JOSA是个很有年代的期刊了，一些几十年前的论文都在这里可以找到。<a href="http://www.opticsinfobase.org/josaa/home.cfm（JOSA A）" target="_blank" rel="external">JOSA A</a> <a href="http://www.opticsinfobase.org/josab/home.cfm (JOSA B" target="_blank" rel="external">JOSA B</a>)</p>
<h3 id="小OE"><a href="#小OE" class="headerlink" title="小OE"></a>小OE</h3><p>小OE的全称是Optical Engineering，最新影响因子为0.958（2013年）。称之为小OE时为了与大OE（Optics Letters）区分开来。感觉小OE还比较好中，毕竟是SPIE下面的期刊。SPIE里面的会议大都比较水，不知道期刊是不是也受了影响。<a href="http://spie.org/x867.xml" target="_blank" rel="external">小OE</a></p>
<h3 id="EL"><a href="#EL" class="headerlink" title="EL"></a>EL</h3><p>EL的全称是Electronics Letters，最新影响因子为1.068（2013年）。对EL我没有什么了解，只知道组里有同学投过。最令我惊讶的是EL的篇幅只有两页，虽然是双栏的，但是这也太短了吧。。。。<a href="http://www.theiet.org/resources/journals/eletters/index.cfm" target="_blank" rel="external">EL</a></p>
<h3 id="OC"><a href="#OC" class="headerlink" title="OC"></a>OC</h3><p>OC的全称是Optics Communications，最新影响因子为1.542（2013年）。对OC我也没啥了解，只知道组里曾经有同学准备投。<a href="http://www.journals.elsevier.com/optics-communications/" target="_blank" rel="external">OC</a></p>
<p>###COL<br>COL的全称是Chinese Optics Letters，最新影响因子为1.073（2013年）。我们曾开玩笑说COL是中国人自己的OL，但水平比OL要低很多，论文也很好中。<a href="http://www.col.org.cn/" target="_blank" rel="external">COL</a></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/11/01/Journals-and-Conference/">
    <time datetime="2017-11-01T12:40:45.000Z" class="entry-date">
        2017-11-01
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-量子隐形传态" class="post-量子隐形传态 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/10/18/量子隐形传态/">量子隐形传态</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/10/18/量子隐形传态/" data-id="cj9h1sgk500066azrrwrq0dur" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="量子隐形传态科普"><a href="#量子隐形传态科普" class="headerlink" title="量子隐形传态科普"></a>量子隐形传态科普</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>这项工作是2015年2月26日以封面标题的形式发表在国际顶级科学期刊《自然》（Nature）上的，作者是中国科学技术大学合肥微尺度物质科学国家实验室的潘建伟院士、陆朝阳教授等人，文章标题是《单个光子的多个自由度的量子隐形传态》（“Quantum teleportation of multiple degrees of freedom of a single photon”）。这里新的成果是“多个自由度”，因为1997年就实现了单个光子的单个自由度的量子隐形传态。那么，什么是光子？（光子是光的最小单元，日常见到的一束光中包含非常多个光子。）什么是自由度？什么是量子？什么是态？什么是量子传态？</p>
<h2 id="物理基础"><a href="#物理基础" class="headerlink" title="物理基础"></a>物理基础</h2><p>一个物理量如果存在最小的不可分割的基本单位，我们就说这个物理量是量子化的，把这个最小单位称为量子。光子就是光量子，一束光至少包含一个光子，再少就不存在了。实验发现，原子中电子的能量不是连续变化的，而是只能取一些分立的值，也就是说，原子中的电子能量是量子化的。量子化是微观世界的普遍现象。20世纪上半叶（主要是从1900年到1930年），普朗克、爱因斯坦、德布罗意、玻尔、海森堡、薛定谔、狄拉克、玻恩、泡利等伟大的物理学家们创立了量子力学，这是我们目前对微观世界最准确的描述。相对论几乎是爱因斯坦独力创造出来的，量子力学却是群星璀璨的产物。爱因斯坦在其中也发挥了非常重要的作用（提出光量子，这是他得诺贝尔物理学奖的原因，——居然不是相对论！），但并不是最重要的，最重要的两个贡献者是普朗克和海森堡。不过上面无论哪一位，都比在世的物理学家伟大多了（杨振宁可能跟泡利相差不是很远？），这是时代的垂青，个人无法改变的。<br>量子力学描述世界的语言跟经典力学有根本区别。经典力学描述一个粒子的状态，说的是它在什么位置，具有什么动量。不言而喻的是，在任何一个时刻这个粒子总是位于某个位置，具有某个动量，即使你不知道是多少。量子力学描述一个粒子的状态，却是给出一个态函数或者称为态矢量，这个态矢量不是位于日常所见的三维空间，而是位于一个数学抽象的线性空间。在这里我们不需要深究这是个什么空间，关键在于两个态矢量之间可以进行“<strong>内积</strong>”（或者称为“点积”）的运算。内积是什么？在三维空间中，两个矢量a和b做内积(a, b)，得到的是它们的长度相乘再乘以夹角的余弦。夹角的余弦，在两个矢量方向相同时等于1，方向相反时等于-1，互相垂直时等于0。所以内积的绝对值越大，就说明两个矢量的方向越接近。对两个态矢量也可以求这样的内积，内积的绝对值表征出它们的相似程度。<br>好，现在不可思议的新概念来了：对于任何一个物理量P（例如位置、动量），态矢量都可以分为两类。一类具有确定的P，称为P的<strong>本征态</strong>，P的取值称为这个本征态的本征值；另一类不具有确定的P，称为P的<strong>非本征态</strong>。非本征态比本征态多得多，如同无理数比有理数多得多。也就是说，绝大多数情况下，一个粒子是没有确定的位置的！等等，什么叫做“没有确定的位置”？是因为粒子跑得太快了，我们看不清吗？量子力学说的不是这种常规（而错误）的理解，而是说：非本征态是一个客观真实的状态，跟本征态同样客观真实，它没有确定的位置是因为它本质上就是如此，而不是因为我们的信息不全。来打个比方，有些状态可以用指向上下左右的箭头来表示，于是你定义“方向”为一个物理量，但是还有些状态是一个圆！圆状态跟箭头状态同样真实，只是没有确定的方向而已。</p>
<p>但是读者还会困惑，因为我们总是可以用仪器去测量粒子的位置，测量的结果总是粒子出现在某个地方，而不是同时出现在两个地方，或者哪里都测量不到。好，下面就是量子力学的关键思想：对P的本征态测量P，粒子的状态不变，测得的是这个本征态的本征值。而对P的非本征态s测量P，会使粒子的状态突然从s变成某个P的本征态f，概率是s与f的内积的绝对值的平方|(s, f)|^2，发生这个突变后测得的就是f的本征值。状态从s突变到f的概率是|(s, f)|^2，实际意思就是这两个态越相似，概率就越大。用上面的例子来说，对箭头状态测方向，状态不变，得到的就是箭头的方向；对圆状态测方向，圆状态会以相同的几率变成任何一个箭头状态，得到的是这个新的箭头状态的方向。对位置的非本征态测量位置，就会测得粒子出现在某个随机的位置，而出现在空间所有位置的几率之和等于1。</p>
<p>怎么知道测量结果是随机的呢？制备多个具有相同状态的粒子，把实验重复多次，就会发现实验结果每次都不一样。没错，量子力学具有本质的随机性，同样的原因可以导致不同的结果，这是跟经典力学的又一大区别。</p>
<p>有人要问了，测量如此奇特，它的本质是什么？回答是：量子力学最大的神秘之一，就是测量的本质谁也不知道！目前只能把测量理解为一种操作定义：对本征态的测量不改变状态，得到本征值；对非本征态的测量随机地把它改变成某个本征态，得到相应的本征值。</p>
<p>你也许会觉得上面这些说法莫名其妙，但是现在绝大多数科学家都对它们奉若圭臬。为什么呢？因为这套奇怪的理论跟实验符合得很好，而经典力学却不能。当然，这是哲学性的原因，而操作性的原因很简单：现在的科学家受的都是量子力学的教育。普朗克有一句非常有趣的话：“新的科学真理并不是由于说服它的对手取得胜利的，而是由于它的对手死光了，新的一代熟悉它的人成长起来了。”诚哉斯言！</p>
<p>事实上，现在仍然有不少人对量子力学提出各种各样的挑战，包括不少专业科学家，民科就更多了（当然挑战相对论的民科更多）。历史上，挑战量子力学的势力更加强大，其中的带头大哥就是——爱因斯坦！老爱坚信粒子应该具有确定的位置和动量，世界的演化应该是决定性的，对前面说的量子力学的不确定性和随机性十分不满。用他自己的话来说，他相信“没有人看月亮的时候，月亮仍然存在”，以及“<strong>上帝不掷骰子</strong>”。</p>
<p>如果是一般人，表达完信念也就没事了。但爱因斯坦是超级伟大的科学家，神一样的人物，他不满足于只做口舌之争，打算按照科学规范，设计一个判决性的实验，以可验证的方式证明量子力学的错误。于是乎，1935年，爱因斯坦（Einstein）、波多尔斯基（Podolsky）和罗森（Rosen）提出了一个思想实验，后人用他们的首字母称为EPR实验。你可以制备两个粒子A和B的“圆”态，使得在这个状态中两个粒子的某个性质（如电子的自旋角动量、光子的偏振）相加等于零，而单个粒子的这个性质不确定。这样一对粒子称为“<strong>EPR对</strong>”，属于量子力学中的“<strong>纠缠态</strong>”，因为这两个粒子的性质不可分割地纠缠在一起了。然后你把这两个粒子在空间上分开很远，任意的远，然后测量粒子A的这个性质。好比你测得A是“上”，那么你就立刻知道了B现在是“下”。好比成龙电影《双龙会》中有心灵感应的双胞胎，一个做了某个动作，另一个无论有多远都会做同样的动作（在相反的方向）。问题是，既然A和B已经离得非常远了，B是怎么知道A发生了变化，然后发生相应的变化的？EPR认为A和B之间出现了“鬼魅般的超距作用”，信息传递的速度超过光速，违反相对论。所以，量子力学肯定有错误。</p>
<p>这个问题非常深邃，直到现在都不断给人以启发。不过量子力学的正统卫道士有一个标准回答：处于纠缠态的A和B是一个整体，当你对A进行测量的时候，A和B是同时发生变化的，并不是A变了之后传一个信息给B，B再变化，所以这里没有信息的传递，不违反相对论。这个回答怎么样？无论你信不信，反正我信了。不过爱因斯坦一直都不信，以这个他参与创建的理论的反对者的身份走完了一生。</p>
<p>在爱因斯坦的时代，EPR实验只能在头脑中进行。随着科技的进步，这个实验可以实现了。1980年代，阿斯佩克特等人做了EPR实验，结果你猜怎么着？完全跟量子力学的预言符合！真的是你测得一个EPR对中的A是“上”的时候，B就变成了“下”。本来是设计出来否定量子力学的，反而验证了量子力学的正确性。这种事在科学史上屡见不鲜。19世纪的时候，泊松主张光是粒子，菲涅耳主张光是波动。。1818年，菲涅耳计算了圆孔、圆板等形状的障碍物产生的衍射花纹。泊松指出，按照菲涅耳的理论，在不透明圆板的正后方中央会出现一个亮点。他认为这是不可能的，于是宣称驳倒了波动说。但菲涅耳和阿拉果立即做实验，果然有个亮斑，波动说大获全胜。后人很有幽默意味地把这个亮点称为泊松亮斑。这正应了尼采的话：“杀不死我的，使我更强大！”</p>
<p>EPR现象既然是一个真实的效应，而不是爱因斯坦等人以为的悖论，人们就想到利用它。量子隐形传态（quantum teleportation）就是一个重要的应用，这是1993年按照量子力学设计出来的一种实验方案。英文单词teleportation就是科幻艺术中biu的一声把人传过去的瞬间传输，tele是远，port是传，所以小编们报道这种新闻总是配传人的图片，《星际迷航》中的Spock发来贺电！可是，量子隐形传态实际做的是把一个粒子A的量子态传输给远处的另一个粒子B，让B变成A最初的状态，<strong>传的是状态而不是粒子</strong>。当然你可以说传人也是把人的所有原子的状态传到远处的另外一堆原子上，组合成一个同样的人。好，我没意见，只不过为了避免混淆，中国的科学家还是小心谨慎地把teleportation翻译成了隐形传态。这个中文名称其实比英文名称好得多，准确而简练，反映出中文的优势。</p>
<h2 id="基本思路以及误解澄清"><a href="#基本思路以及误解澄清" class="headerlink" title="基本思路以及误解澄清"></a>基本思路以及误解澄清</h2><p>量子隐形传态的基本思路是这样：让第三个粒子C跟B组成EPR对，而C跟A离得很近，跟B离得很远。让A跟C发生相互作用，改变C的状态，于是B的状态也发生了相应的变化。这时A和C这个两粒子集合的状态有四种可能，分别对应00、01、10、11四个字符串。B的状态也相应地有四种可能，每一种可能都跟A最初的状态（即你想传输的目标状态）有一定程度的相似之处，可以通过某些量子力学的操作变成目标状态。对A和C的整体做一次测量，A和C就随机地突变到了00、01、10、11这四种状态中的某一个上，B也突变到了相应的状态。现在你得到了一个两比特的字符串，00、01、10或11，你可以把它理解为一个密码。把这个密码通过经典的通讯手段（比如电话、光缆）告诉B那边的人，对B按照密码进行操作，就得到了A最初的状态。由此可见，量子隐形传态的基本元素包括中介粒子、密码和经典信道。</p>
<p>这里要澄清一个常见的误解。许多人把量子隐形传态当成了瞬间传输，不花时间就能传输到无限远处，然后高呼推翻了相对论。还有人以为凭这一招，信息传播速度就可以超光速，我们可以跟离地球500万光年的星球即时通话。这是完全错误的！仔细看上面的流程，通过测量让各个粒子的状态突变确实可以不花时间，但是光凭这一步是无法得到目标状态的。为了知道对B要做什么操作才能得到目标状态，必须把那个两比特的字符串传过去，这就要通过经典的通信，而经典通信不能超过光速。由于有传输密码这一步卡着，所以量子隐形传态不能超光速。</p>
<p>对这个结论有些沮丧吗？我得强调一句，成熟的科学理论不是这么容易推翻的。量子力学和相对论不是完全没有矛盾，但那是跟广义相对论有矛盾（引力问题），狭义相对论跟量子力学还是很和谐的。量子隐形传态是个按照标准理论设计出来的方案，当然不会跟标准理论冲突。与其把它理解成一个推翻正统的革命家，不如把它理解成一个在现行体制下发挥奇思妙想的工艺大师。</p>
<p>还有一个常见的误解，是把量子隐形传态当成复制状态，然后就开始担忧两地同时出现一个自己，到底谁才是自己。这种理解也是错误的。仔细看量子隐形传态的流程，最终结果是B变成了A最初的状态，但A的状态也改变了。也就是说，任何时刻都只有一个粒子处于目标状态。如果要说这是复制的话，也是一种破坏性的复制，造出一个复本的同时就要把原本销毁。所以样品不会增多，只是从一个地方转移到了另一个地方而已。</p>
<p>总而言之，量子隐形传态是以不高于光速的速度、破坏性地把一个粒子的未知状态传输给另一个粒子。打个比方，用颜色表示状态，A粒子最初是红色的，通过隐形传态，我们让远处的B粒子变成红色，而A粒子同时变成了绿色。但是我们完全不需要知道A最初是什么颜色。无论A是什么颜色，这套方法都可以保证B变成A最初的颜色，同时A的颜色改变。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/10/18/量子隐形传态/">
    <time datetime="2017-10-18T14:16:04.000Z" class="entry-date">
        2017-10-18
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-char和byte的区别" class="post-char和byte的区别 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/10/16/char和byte的区别/">char和byte的区别</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/10/16/char和byte的区别/" data-id="cj9h1sgk100046azrp46z0btj" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="byte和char的区别"><a href="#byte和char的区别" class="headerlink" title="byte和char的区别"></a>byte和char的区别</h2><p>byte是字节数据类型，是由符号的，占据一个字节。char是字符数据类型，是没有符号的，占两个字节，它是一个16位二进制的Unicode字符。如果表示中文的话，需要用char，byte是不行的，不过如果制定charset的话可能可以，但是还没有尝试过，如果表示英文字母，byte和char是通用的～</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/10/16/char和byte的区别/">
    <time datetime="2017-10-16T14:32:31.000Z" class="entry-date">
        2017-10-16
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-BFSTraverseForArray" class="post-BFSTraverseForArray post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/10/16/BFSTraverseForArray/">BFSTraverseForArray</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/10/16/BFSTraverseForArray/" data-id="cj9h1sgjp00006azr04q0r7cw" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>这里主要是针对用邻接矩阵表示的图的BFS算法，搜索技巧是整个图算法领域的核心，而BFS算法是后面的最短路径算法，D算法等算法的基础。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>利用队列的性质，首先将跟节点放入队列，每次取出一个，并把取出来的鸡节点的Flag设为True，也就是说每个节点只能被遍历一次，同时把该节点的相邻的节点放入队列中，那么拿出队列的顺序就是遍历的顺序，从而实现了广度优先搜索。</p>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 这个是在存在邻接矩阵的情况下进行广度优先搜索以及深度优先搜索的代码</div><div class="line"> */</div><div class="line"></div><div class="line">package xyz.sherrystar.algo;</div><div class="line"></div><div class="line">import java.util.LinkedList;</div><div class="line">import java.util.Queue;</div><div class="line"></div><div class="line">public class TraverseForArray &#123;</div><div class="line">    private  int number = 9;</div><div class="line">    private boolean[] flag;</div><div class="line">    private String[] vert = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;&#125;;</div><div class="line">    private int[][] edges=&#123;</div><div class="line">            &#123;0,1,0,0,0,1,1,0,0&#125;,&#123;1,0,1,0,0,0,1,0,1&#125;,&#123;0,1,0,1,0,0,0,0,1&#125;,</div><div class="line">            &#123;0,0,1,0,1,0,1,1,1&#125;,&#123;0,0,0,1,0,1,0,1,0&#125;,&#123;1,0,0,0,1,0,1,0,0&#125;,</div><div class="line">            &#123;0,1,0,1,0,1,0,1,0&#125;,&#123;0,0,0,1,1,0,1,0,0&#125;,&#123;0,1,1,1,0,0,0,0,0&#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"></div><div class="line">    //图的广度搜索</div><div class="line">    public void BFSTraverse()&#123;</div><div class="line">       flag = new boolean[number];</div><div class="line">        Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();</div><div class="line">        for (int i = 0; i &lt; number ; i++) &#123;</div><div class="line">            if(flag[i] == false) &#123;</div><div class="line">                flag[i] = true;</div><div class="line">                System.out.println(vert[i]+&quot; &quot;);</div><div class="line">                queue.add(i);</div><div class="line">                while(!queue.isEmpty()) &#123;</div><div class="line">                    int j = queue.poll();</div><div class="line">                    for (int k = 0; k &lt; number; k++) &#123;</div><div class="line">                        if(edges[j][k] == 1 &amp;&amp; flag[k] == false) &#123;</div><div class="line">                            flag[k] = true;</div><div class="line">                            System.out.println(vert[k]+&quot; &quot;);</div><div class="line">                            queue.add(k);</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/10/16/BFSTraverseForArray/">
    <time datetime="2017-10-16T12:04:33.000Z" class="entry-date">
        2017-10-16
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-QuickSort1" class="post-QuickSort1 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/10/15/QuickSort1/">QuickSort1</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/10/15/QuickSort1/" data-id="cj9h1sgjz00036azr5lg8zkex" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="快速排序简介"><a href="#快速排序简介" class="headerlink" title="快速排序简介"></a>快速排序简介</h2><p>快速排序是一种很有效的排序方法，它同样采用了分治的思想，分别由三部分组成，首先把数组S划分为两个数组，其中数组A中的数都小于S[q],而数组B中的数都大于S[q],通过递归调用快速排序，对子数组再次进行排序。</p>
<h2 id="插入排序性能分析"><a href="#插入排序性能分析" class="headerlink" title="插入排序性能分析"></a>插入排序性能分析</h2><p>快速排序的最坏时间复杂度为o(n^2),这是在每次选择标准值的时候都选中了最大值或者最小值，但是一般情况下，他的期望时间复杂度和归并算法是一样的，并且在实际情况中验证它是排序应用中最好的选择。</p>
<h2 id="插入排序算法的Java实现"><a href="#插入排序算法的Java实现" class="headerlink" title="插入排序算法的Java实现"></a>插入排序算法的Java实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">package xyz.sherrystar.algo;</div><div class="line"></div><div class="line">public class QuickSort &#123;</div><div class="line">    public int partition(int[] A,int p,int r) &#123;</div><div class="line">        int x = A[r];//令数组的最后一个数为标准值</div><div class="line">        int i = p-1;</div><div class="line">        for (int j = p; j &lt; r; j++) &#123;</div><div class="line">            if(A[j] &lt; x) &#123;</div><div class="line">                i++;</div><div class="line">                int change = A[i];//实现A[i]and A[j]的交换</div><div class="line">                A[i] = A[j];</div><div class="line">                A[j] = change;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        int c = A[i+1];</div><div class="line">        A[i+1] = A[r];</div><div class="line">        A[r] =c;  //把把标准值更换到对应的位置</div><div class="line">        return i+1;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int[] getSorted(int[] A,int p,int r) &#123;</div><div class="line">        if(p&lt;r) &#123;</div><div class="line">            int q = partition(A,p,r);//实现了对子数组的原址重排</div><div class="line">            getSorted(A,p,q-1);</div><div class="line">            getSorted(A,q+1,r);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return A;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://cl.ly/1a1Y0s0G072m" alt="haha"><br><img src="/img/time.jpg" alt="sadasd"></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/10/15/QuickSort1/">
    <time datetime="2017-10-15T11:26:15.000Z" class="entry-date">
        2017-10-15
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-InsertSort" class="post-InsertSort post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/10/12/InsertSort/">InsertSort</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/10/12/InsertSort/" data-id="cj9h1sgjv00016azr9xe84t5e" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="插入排序简介"><a href="#插入排序简介" class="headerlink" title="插入排序简介"></a>插入排序简介</h2><p>插入排序就像人们排好手中的扑克牌的方法，人们对手中扑克牌进行排序的时候，已经在手上的排的排序好的，每次从牌堆中取出一张牌的时候，都会与手中的牌进行大小比较，从右边开始，依次比较，最后放到一个合适的位置</p>
<h2 id="插入排序性能分析"><a href="#插入排序性能分析" class="headerlink" title="插入排序性能分析"></a>插入排序性能分析</h2><p>对于只有少量元素的排序，插入排序是一种有效的算法，它的编码思路是非常简单的，并且在重新排序的过程中，该方法仅仅需要优有限个数字存储在数组外面，但是，对于大量元素的排序，该算法显然不是一个很好的选择，经过两次循环的它的算法复杂度达到了o(n^2),当数据量比较大的时候，就会很复杂。</p>
<h2 id="插入排序算法的Java实现"><a href="#插入排序算法的Java实现" class="headerlink" title="插入排序算法的Java实现"></a>插入排序算法的Java实现</h2><p>`package xyz.sherrystar.algo;</p>
<p>public class InsertionSort {</p>
<pre><code>public static int[] getSorted(int[] unSorted) {

    for (int i = 1; i &lt;unSorted.length ; i++) {
        int key = unSorted[i];
        int j=i-1;
        while(j &gt;= 0 &amp;&amp; unSorted[j] &gt; key) {
            unSorted[j+1] = unSorted[j];
            j--;
        }
        unSorted[j+1] = key;
    }
    return unSorted;
}
</code></pre><p>}`</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/10/12/InsertSort/">
    <time datetime="2017-10-12T06:22:14.000Z" class="entry-date">
        2017-10-12
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-hello-world" class="post-hello-world post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/10/10/hello-world/">Hello World</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/10/10/hello-world/" data-id="cj9h1sgk300056azrvgkeao7c" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/10/10/hello-world/">
    <time datetime="2017-10-10T03:58:19.000Z" class="entry-date">
        2017-10-10
    </time>
</a>
    
    
    </footer>
</article>






  
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2017/11/01/Journals-and-Conference/">Journals and Conference</a>
          </li>
        
          <li>
            <a href="/2017/10/18/量子隐形传态/">量子隐形传态</a>
          </li>
        
          <li>
            <a href="/2017/10/16/char和byte的区别/">char和byte的区别</a>
          </li>
        
          <li>
            <a href="/2017/10/16/BFSTraverseForArray/">BFSTraverseForArray</a>
          </li>
        
          <li>
            <a href="/2017/10/15/QuickSort1/">QuickSort1</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2017 John Doe
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>